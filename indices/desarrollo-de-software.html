<!DOCTYPE html>
<html lang="es">

<head>
    <link rel="stylesheet" href="../css/estilos.css">
    <link rel="stylesheet" href="../java/java.js">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
    <title>ProyectoIntermodular</title>
    <style>
        #imgDIV {
            width: 30%;
            height: 30%;
            display: flex;
            padding-left: 40%;
            margin-top: 1.5em;
        }

        #imgBonita {
            width: 100%;
            height: 100%;
            display: flex;
            padding-right: 10%;
            margin-top: 1.5em;
        }

        #imgFasesDesarrollo {
            width: 70%;
            height: 70%;
            display: flex;
            padding-right: 10%;
            margin-top: 1.5em;

        }

        h2 {
            font-size: 1.8em;
        }
        .titulo-centrado {
        text-align: center; /* Centra horizontalmente el título */
    }
    .contenedor-ajustartexto {
        padding-left: 1.5em; /* Añade espacio solo a la izquierda */
        max-width: 100%; /* Asegura que el ancho del texto se adapte */
    }

    .imagen-centrada {
        display: block; /* Hace que la imagen sea un elemento de bloque */
        margin: 1.5em auto; /* Centra horizontalmente y añade un margen superior e inferior */
        width: 40%; /* Ajusta el ancho de la imagen */
        height: auto; /* Mantiene las proporciones */
    }
    

    
    </style>
</head>

<body>
    <div class="fondo">
        <hr>
        </hr>
        <hr>
        </hr>
        <div id="indice" style="display: flex; align-items: center;">
            <img src="../imagenes/Logotipo.png" id="logotipo" alt="Logotipo">

            <a class="primero" href="../index.html">
                <h1 class="text-shadow-pop-top">Development Project</h1>
            </a>

            <div id="horaActual" style="display: flex; align-items: center;"></div>
        </div>
        <!-- ALEX -->
        <br></br>
        <br></br>
        <br></br>
        <br></br>
        <h1 class="tracking-in-contract-bck">El Desarrollo Software</h1>
        <p> Empezaremos hablando sobre lo que engloba el desarrollo software, que entendemos como proceso de diseñar,
            crear, implementar y mantener aplicaciones o sistemas informáticos. Es decir, engloba lo que sería una
            idea hasta la entrega del producto funcional y su evolución con el paso del tiempo</p>
        <div class="separadorDeTema"></div>
        <!-- PRIMER CONTENEDOR CONCEPTO SOFTWARE-->
        <div class="contenedor1">
            <div class="contenedor-imagen">
                <img src="../imagenes/software1.png" alt="Foto de una pantalla con codigo de desarrollo software">
            </div>
            <div class="separadorDeTema"></div>
            <div class="Contenedor1-texto">
                <h2>Hardware del ordenador</h2>
                <p>Tendremos que hacer también referencia sobre los programas que se ejecutan en el ordenador, lo que
                    permite realizar determinadas tareas sobre el hardware, y los datos necesarios para la ejecución
                    de los programas. </p>
                <p>Para el concepto de software podemos decir que es un conjunto de instrucciones, datos o programas
                    que permiten que un Sistema Informatico haga tareas especificas, es decir, es la parte intangible de
                    un S.I.
                </p>
                <p>Pero para hacer comprender mejor este concepto, vamos a ver las distintas partes del hardware de un
                    ordenador, que son tres:
                </p>

                <br>
                <div class="separadorDeTema"></div>
                <p>Hay diferentes clasificaciones:</p>
                <ol>
                    &emsp;<li><strong>&emsp; Unidad central de proceso (CPU):</strong> esta parte ejecuta las
                        instrucciones
                        que hay en un programa. Aunque las instrucciones pueden ser muy complejas, al final se traducen
                        en operaciones aritméticas fáciles (sumas, restas, etc.) y lógicas (OR, AND, etc.) que se hacen
                        sobre <b>bits</b>. La CPU tiene diferentes partes:
                        <ul>
                            &emsp;&emsp;<li><i>&emsp;&emsp;Unidad aritmético-lógica (ALU):</i> ejecuta los dos
                                tipos de operaciones encargadas por la unidad de control con los datos que recibe, y
                                devuelve
                                el resultado.
                            </li>
                            &emsp;&emsp;<li><i>&emsp;&emsp;Unidad de control (UC):</i> recoge las instrucciones de la
                                memoria principal y ordena su ejecución enviando señales a la ALU y a los registros
                            </li>
                            &emsp;&emsp;<li><i>&emsp;&emsp;Registros</i> forman el almacenamiento interno de la CPU e
                                intervienen
                                en la ejecución de las instrucciones. Hay varios, como pueden ser el contador de
                                programa y el
                                registro de instrucción.
                            </li>
                        </ul>
                    </li>
                    &emsp;<li><b>&emsp;&emsp;Memoria principal o memoria RAM: </b> tiene las instrucciones que hay que
                        ejecutar
                        y los datos sobre los que deben operar estas instrucciones. La CPU coge estas instrucciones de
                        la RAM y envía órdenes
                        necesarias para su ejecución. Es una memoria volátil, osea que, su contenido desaparece cuando
                        se apaga el ordenador
                    </li>
                    &emsp;<li>&emsp;&emsp;<b>Unidad de entrada/salida</b> es la que permite la comunicación con el
                        exterior, llevando la
                        información a través de <b>periféricos</b> . Y estos pueden ser de varios tipos:
                        <ul>
                            &emsp;<li>&emsp;&emsp;<i>De entrada:</i> le dan al ordenador datos e instrucciones. Pueden
                                ser (ratón, teclado, etc).</li>
                            &emsp;<li>&emsp;&emsp;<i>De salida:</i> llevan la información al exterior, del ordenador al
                                usuario. Pueden ser (pantalla, impresora, etc).</li>
                            &emsp;<li>&emsp;&emsp;<i>De entrada/salida</i> proporcionan información al ordenador y
                                también envían infromación del ordenador
                                al usuario. Aquí podemos encontrar, (módem, tarjeta de red, etc). También podemos
                                incluir los dispositivos de
                                almacenamiento, como son (los discos duros, memorias flash, etc).</li>
                        </ul>
                    </li>
                </ol>
                <br>
                &emsp;<img src="../imagenes/hardwareCPU.png"
                    alt="la estructura de un ordenador consta de una CPU, y todos sus componentes como la ALU, Unidad de Control, etc">
                <p> Para la interconexión de estos elementos, se utilizan una serie de conexiones llamadas
                    <b>&nbsp;buses</b>&nbsp;que son representadas por flechas.</p>
            </div>
        </div>
        <!-- SEGUNDO CONTENEDOR Código fuente, objeto y ejecutable-->
        <div class="contenedor2">
            <div class="contenedor-imagen">
                <img id="imgBonita" src="../imagenes/compilador-interprete-988x640.png"
                    alt="Imagen de una foto de un codigo fuente">
            </div>
            <div class="Contenedor2-texto">
                <h1 class="focus-in-expand-fwd">Códigos</h1>
                <h2>Código Fuente</h2>
                <p>
                    Son muchas instrucciones agrupadas escritas por un
                    programador
                    en algún lenguaje de programación, y hay muchos, como pueden serlo mas conocidos/ importantes,
                    Python, Java o C++.
                </p>
                <p>
                    Podemos decir el código fuente es:
                </p>
                <ul>
                    <li>Editable y legible para desarrolladores ( dar ejemplo de que es nuestra manera de tener una
                        relacion mas cercana
                        con el sistema informático)</li>
                    <li>Utilizado para definir la lógica y funcionalidades del programa.</li>
                    <li>Entrada para los procesos de compilación o interpretación.</li>
                </ul>
                <p>Esto esencial porque es la el intermediario entre el lenguaje de programacion y nuestro lenguaje.</p>
                <h2>Código Objeto</h2>
                <p>
                    Es la representacion generada al compilar el código fuente. Compuesto por instruccion pero en
                    lenguaje de máquina,
                    (aún no esta listo para ejecutarse).
                </p>
                <p><b>Se representa en binario (0110 1101).</b></p>
                <p>Lo principal del código fuente es:</p>
                <ul>
                    <li>Que es específico para entender el hardware y sistema operativo que es donde se ejcutará.</li>
                    <li>Dificil de leer por los humanos.</li>
                    <li>Puede incluir referencia a librerias externas, esto lo vereos en el siguiente código.</li>
                </ul>
                <p>Para que el programa sea ejecutable, primero deberemos tener estos pasos, ensamblado, enlazado y
                    carga.
                </p>
                <h2>Código Ejecutable</h2>
                <p>
                    Este es el producto final para ser ejecutado por el sistema operativo. Es el resultado de los dos
                    códigos anteriores con todas las librerías para que funcione. Lo usará el usuario final para
                    interactuar con el programa.
                </p>
                <div class="separadorDeTema"></div>
                <div>
                    <p><b>Tipos de traductores</b></p>
                    <ol>
                        <li>
                            <p><b>Compiladores.</b>&nbsp;Estos traductores hacen su tarea de forma global. Es un único
                                proceso se analiza
                                todo el código fuente, se genera el código objeto y se almacena el resultado. Si el
                                programa fuente esta
                                correctamente escrito esto se podrá llevar acabo, en caso de no estarlo no se generará
                                el código. El código
                                objeto generando como resultado de la compilación, dependiendo del tipo de compilador,
                                se podrá ejecutar
                                directamente o puede que se necesiten otros pasos antes de que el programa sea
                                ejecutable, como los pasos
                                de ensamblado, enlazado y carga. Una vez obtenido el código ejecutable, se podrá
                                ejecutar tantas veces
                                como se desee, sin necesidad de volverlo a compilar.
                            </p>
                        </li>
                        <li>
                            <p>
                                <b>Intérpretes.</b>&nbsp;A diferencia de lo que pasa con los compiladores, estos hacen a
                                la vez el proceso detraducción
                                y el de ejecución. Su forma de trabajo es que, primero analizan los bloques del programa
                                fuente, generan el código
                                objeto y lo ejecutan, luego se repite este proceso hasta que acaba el programa. En la
                                etapa de ejecución, se
                                pasa el control al código objeto generado y se espera a que acabe su ejecución. Así,
                                cada fragmento de código fuente
                                solo se almacena provisionalmente.
                                <br>
                                En caso de ser lenguaje de Java, se combinan la comilación y la interpretación. El
                                programa se compila, se genera
                                un formato intermedio llamado bytecode y el resultado es interpretado por la máquina
                                virutal de Java.
                            </p>
                        </li>
                    </ol>
                    <br>
                    <p>Hay una serie de harramientas para realizar el proceso desde la generación del código fuente
                        hasta la ejecución del programa</p>
                    <ul>
                        <li>
                            <p>Para escribir código fuente se puede emplear un editor de textos simple o alguna
                                herramienta de programación.
                                Hay programas como Notepad++ o Sublime que nos permiten crear código fuente en
                                diferentes lenguajes de programación
                                facilitando así el trabajo de los programadores.
                            </p>
                        </li>
                        <li>
                            <p>
                                Dependiendo de si usamos un lenguaje de programación u otro, emplearemos un compilador o
                                un interpréte.
                            </p>
                        </li>
                        <li>
                            <p>
                                También puede ser que el código generado no sea ejcutable, entonces será necesario
                                emplear un entorno de desarrollo
                                integrado, una aplicación informática compuesta por un cojunto de herramientes que
                                facilitan a la persona encargada
                                de la programación su tarea y dan rapidez en la creación de programas. La mayoría de
                                estos entornos, tienen un
                                depurador, ( que nos ayudarán en las detenciones y correcciones de errores de
                                programación), una herramienta de control
                                de verisiones y un constructor de interfaz gráfica.
                    </ul>
                    <img src="../imagenes/traductores.png" alt="se aprecia como ha evolucionado la programación">
                </div>
            </div>
        </div>
        <!--LENGUAJES DE PROGRAMACIÓN-->
        <div class="contenedor1">
            <div>
                <img src="../imagenes/lenguajesDeProgramacion.png"
                    alt="Muestra los lenguajes de programación más conocidos">
            </div>
            <div class="contenedor1-texto">

                <h2>Lenguajes de programación</h2>
                <p>Los lenguajes de programación tienen todos algo en común y es que, son instrucciones de los programas
                    que ha de ejecutar el ordenador para resolver algún tipo de problema.
                </p>
                <p>Los elementos básicos que se recogen en todos los lenguajes de programación son estos:</p>
                <ul>
                    <li><strong>Identificadores</strong> nombre simbólicos, que damos a algunos elementos de
                        programación, como son variables, tipos, módulos, etc</li>
                    <br>
                    <li><strong>Constantes</strong> son datos que no cambian su valor en el programa, a no ser, que
                        nosotros
                        queramos modificarlo pero sirve justamente para no ir cambiando todo a mano.
                    </li>
                    <br>
                    <li><strong>Operadores</strong> símbolos que muestran operaciones entre variables, constantes, etc.
                        (suma (+), resta (-)...).</li>
                    <br>
                    <li><strong>Instrucciones</strong> símbolos especiales que representan estructuras de procesamiento
                        y
                        de definición de elementos de programación y lo hace de manera consecutiva.
                    </li>
                    <br>
                    <li><strong>Comentarios</strong> se utiliza normalmente para ayudarte a guiarte en el programa,
                        <i>(porque seamos sinceros, si pasan 2 dias ¿sabes que hace no?, pero ¿y si lo dejas 1 mes y lo
                            tienes
                            que reusar o cualquier otra cosa, te acordarías? No, por lo tanto se utiliza para saber que
                            se va
                            realizando en el programa).
                        </i>
                    </li>
                </ul>
                <!--PUNTOS ANIMADOS-->
                <div class="loader">
                    <div class="circle">
                        <div class="dot"></div>
                        <div class="outline"></div>
                    </div>
                    <div class="circle">
                        <div class="dot"></div>
                        <div class="outline"></div>
                    </div>
                    <div class="circle">
                        <div class="dot"></div>
                        <div class="outline"></div>
                    </div>
                    <div class="circle">
                        <div class="dot"></div>
                        <div class="outline"></div>
                    </div>
                </div>
                <!--PUNTOS ANIMADOS FIN-->

                <!--LENGUAJE NIVEL BAJO ACORDEON-->
                <div class="contenedor-acordeon">
                    <div class="acordeon">
                        <input type="checkbox" name="acordeon" id="btn-acordeon2" class="btn-acordeon">
                        <label for="btn-acordeon2">
                            Lenguajes de bajo nivel lenguajes de máquinas
                        </label>
                        <div class="contenido-acordeon">
                            <p>Siendo el primer lenguaje de programación, es el único lenguaje de programación que
                                entiende directamente la máquina. Utiliza el alfabeto binario ( números 0 y 1), para
                                establecer la comunicación con el hardware de la máquina. <br>
                                Dejó de usarse por ser complejo y fue sustituido por otros más cercanos al lenguaje
                                natural.
                            </p>
                        </div>
                    </div>
                </div>
                <!--LENGUAJE INTERMEDIO O LENGUAJES ENSAMBLADORES ACORDEON-->
                <div class="contenedor-acordeon">
                    <div class="acordeon">
                        <input type="checkbox" name="acordeon" id="btn-acordeon3" class="btn-acordeon">
                        <label for="btn-acordeon3">
                            Lenguaje intermedio o lenguaje ensamblador
                        </label>
                        <div class="contenido-acordeon">
                            <p>Se sustituyen los anteriores lenguajes que utilizaban códigos numéricos o direcciones de
                                memoria,
                                por unos más textuales, que son equivalentes a las instrucciones de la máquina, o sea,
                                de
                                forma simbólica <br>
                                En definición este lenguaje actúa como puente entre el código fuente escrito por los
                                programadores y el código de la máquina, de ahí su nombre de lenguaje intermedio. Tiene
                                varios inconvenientes;
                                tiene un repertorio muy reducido de instrucciones, tiene formato muy rígido y depende
                                mucho
                                del hardware.
                            </p>
                        </div>
                    </div>
                </div>
                <!--LENGUAJE DE NIVEL ALTO O LENGUAJE EVOLUCIONADO-->
                <div class="contenedor-acordeon">
                    <div class="acordeon">
                        <input type="checkbox" name="acordeon" id="btn-acordeon4" class="btn-acordeon">
                        <label for="btn-acordeon4">
                            Lenguaje de alto nivel o lenguaje evolucionado
                        </label>
                        <div class="contenido-acordeon">
                            <p>Este lenguaje libera al programador de tareas más costosas. Esto se consigue así por el
                                nivel
                                de abstracción
                                que ofrecen estos lenguajes, muy necesario para programadores.
                            </p>
                            <ul>
                                <li>Instrucciones expresan entre caracteres alfanuméricos, numericos y especiales.</li>
                                <li>Se pueden definir variables para recoger los datos que se vayan a tratar.</li>
                                <li>Pueden incluirse lineas con comentarios</li>
                                <li>Disponen de instrucciones mu potentes de tipo aritmetico, logicas de tratamiento de
                                    caracteres, etc.</li>
                                <li>Tiempo de codificacion y puesto a punto de los programas es menor</li>
                                <li>Resultan mas faciles de corregir y modificar.(ahora tiempo)</li>
                                <li>La curva de aprendizaje de las personas es más corta y menos pronunciadad que con
                                    los
                                    otros lenguajes.</li>
                            </ul>
                            <p><strong>Pero también hay inconvenientes:</strong></p>
                            <ul>
                                <li>No se traducen directamente por lo que precisan de un pequeño tiempo de proceso de
                                    traducción</li>
                                <li>La memoria aumenta, por el traductor, el programa traducido, etc. Aunque, tampoco es
                                    problema, ya que
                                    con el hardware que hay hoy eso no supone un gran problema.</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="contenedor2">
            <div class="contenedor-imagen">
                <img src="../imagenes/ProcesoDelCodigo.PNG" alt="">
            </div>
            <div class="Contenedor2-texto">
                <p><strong>LENGUAJES DE PROGRAMACIÓN ESTRUCTURADOS
                    </strong></p>
                <!-- PREGUNTAR JOSELUIS-->
                <p>Son caracterizados por el empleo exclusivo de 3 estructuras para la creación de cualquier programa.
                    <br> Estructura secuencial, alternativa y repetitiva.
                </p>
                <p>Las aplicaciones tambien usan diversos componentes de software, llamados módulos.
                    <br>Los módulos hacen determinadas tareas de procesamiento, para lo que requiere utilizar datos.
                </p>
                <p>En los módulos se van pasando los datos llamados parámetros y a veces nos devuelven
                    resultados</p>
                <p>Hay 2 tipos de modelos que son:</p>
                <ul class="tabulado">
                    <li>procedimientos</li>
                    <li>funciones</li>
                </ul>
                <p>Su diferencia es que las funciones devuelven algún datos mientras que las otras no lo hacen.
                    <br>Luego podemos hablar sobre el Diagrama de Estructuras. Cada rectángulo es un módulo y las
                    flechas que los unen son las llamadas.
                </p>
                <img class="contenedor-imagen" src="../imagenes/lenguajesDeProgramacioneEstruct.png"
                    alt="Diagrama de módulos unidos">
                <label class="etiquetaDeFoto">Modulo A es el módulo llamador. <br> Las líneas que salen de él son las
                    invocaciones. <br>
                    Los módulos B y C son los módulos llamados. <br> A su vez llaman a otros módulos más.
                </label>
                <!--Foto sacada de: https://www.google.com/url?sa=i&url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DC2rDTMrxSKQ&psig=AOvVaw0PQlnWspB66hTgSysSto1-&ust=1732905659766000&source=images&cd=vfe&opi=89978449&ved=0CBQQjRxqFwoTCIie5ffX_4kDFQAAAAAdAAAAABAI-->
                <div class="contenedor-acordeon">
                    <div class="acordeon">
                        <input type="checkbox" name="acordeon" id="btn-acordeon5" class="btn-acordeon">
                        <label for="btn-acordeon5">
                            Lenguaje orientado a objetos
                        </label>
                        <div class="contenido-acordeon">
                            <!--PONER EN NEGREITA SIN FALLOS-->
                            <p>El lenguaje orientado a objetos surgió más tarde, supusieron un cambio de visión en
                                relacion a
                                desarrollo softaware. Segun el paradigma orientado a objetos, una aplicacion informatica
                                consta
                                de diversos objetos que interactuan entre si.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>












        <!-- Raul -->
        <br></br>
        <br></br>
        <br></br>
        <br></br>
        <!--PRIMER APARTADO -->
        <div class="contenedor2">
            <div class="contenedor-imagen">
                <img id="imgCodigoFuente" src="../imagenes/imagenmaquinavirtual.jpg" alt="Imagen de Maquina Virtual">
            </div>
            <div class="Contenedor2-texto">
                <h1 class="titulo">Maquina Virtual y su utilidad</h1>
                <p>Una máquina virtual es una aplicación que ejecuta los programas como si fuese una máquina
                    real, aunque no lo sea. Existen dos tipos de máquinas virtuales:</p>
                <ol>
                    <li><strong>Maquinas virtuales de sistema:</strong>son aplicaciones que emulan a un ordenador por
                        completo, de forma que se puede instalar en su interior otro sistema operativo
                        con su propio disco duro, memoria, tarjeta gráfica, etc. Se puede trabajar en la
                        máquina virtual de igual forma que si se tratase de una máquina real. Son ejemplos
                        de aplicaciones de este tipo VMware Workstation y Virtual Box. Se pueden
                        utilizar estas máquinas virtuales para disponer de manera sencilla de varios sistemas
                        operativos en el mismo ordenador (instalando uno de ellos en la máquina
                        real y otro diferente en la virtual).</li>
                    <li><strong>Maquinas virtuales de proceso:</strong>estas máquinas ejecutan un proceso concreto dentro
                        de un sistema operativo. Este tipo de máquinas se inician cuando se lanza el
                        proceso que se desea ejecutar y se detienen cuando este termina. El objetivo de
                        estas máquinas es permitir que un programa se ejecute de igual forma en cualquier
                        plataforma, proporcionando un entorno de ejecución independiente del hardware
                        y del sistema operativo y ocultando los detalles de la plataforma subyacente. El
                        ejemplo más popular de máquina virtual de proceso es la máquina virtual de Java.</li>
                </ol>
                <br></br>

                <h2>Maquina virtual de Java</h2>
            
                <ul>
                    <li><strong>Máquina virtual de Java:</strong>es el
                        ejemplo típico de máquina virtual de proceso. Su ventaja es que dota de portabilidad al
                        lenguaje, de manera que un programa compilado en Java se puede ejecutar en cualquier
                        plataforma. Esto se debe a que el programa escrito en Java realmente no es ejecutado
                        por el procesador del ordenador, sino por la JVM.</li>
                </ul>
                <h3>El proceso que se lleva a cabo para poder ejecutar un programa escrito en Java</h3>
                <ul>
                    <li>La persona encargada de la programación escribe el código fuente del programa
                        en lenguaje Java mediante el empleo de un editor de textos, para lo que puede
                        usar el que viene incorporado en el entorno de desarrollo integrado. De esta manera,
                        se genera un archivo de texto con extensión .java.</li>
                    <li>Se compila el programa fuente mediante el compilador javac, que también viene
                        incorporado en el entorno de desarrollo, lo que da lugar a un fichero con extensión
                        .class, en caso de que no haya errores en el código fuente. Este fichero contiene
                        código en un lenguaje intermedio llamado bytecode, que es independiente del ordenador
                        y del sistema operativo en el que se ejecuta.</li>
                    <li>La máquina virtual de Java traduce el archivo con extensión .class al código binario
                        para que el programa pueda ser ejecutado. Como la JVM está disponible en
                        diferentes sistemas operativos, los archivos con extensión .class se pueden ejecutar
                        en distintas plataformas, como Windows, Linux, macOS, etcétera.</li>
                        <img src="../imagenes/imagenmaquinavirtualjava.png" alt="">
                </ul>

            </div>




        </div>



        <br></br>
        <br></br>
        <!--SEGUNDO APARTADO -->

        <h2 class="titulo-centrado">Razón de ser de la ingeniería del software.</h2>
        <p>la ingeniería del software, que es una disciplina
            para el desarrollo de software que surgió a partir de la ingeniería de sistemas y de
            hardware. La definición que propuso Fitz Bauer para la ingeniería del software es: «el establecimiento
            y uso de principios de ingeniería para llegar a un obtener un software rentable,
            que sea fiable y que funcione eficientemente en máquinas reales».</p>
            <img class="imagen-centrada" src="../imagenes/imageningenieria.png" alt="Ingenieria del software">

        <br></br>
        <!--TERCER APARTADO -->
        <div class="contenedor1">
    
            <div class="contenedor-ajustartexto">
                <h1 class="titulo">Fases del desarrollo de una aplicación informática.</h1>
                <ol>
                    <li><strong>Análisis:</strong> el objetivo de esta tarea es analizar las necesidades de los usuarios potenciales
                        del software para determinar qué debe hacer la aplicación y, de acuerdo
                        con ello, escribir una especificación precisa de dicho sistema. Durante esta fase
                        se pretende responder a las siguientes preguntas: qué información ha de ser procesada,
                        qué función y rendimiento se desean, qué interfaces deben establecerse,
                        qué restricciones de diseño existen y qué criterios de validación se necesitan para
                        definir un sistema correcto. Para ello, como es obvio, es necesario realizar una actividad
                        inicial de comunicación con el cliente que ha encargado el desarrollo de la
                        aplicación, y una vez obtenida la información necesaria, se podrá modelar el sistema.
                        Como resultado, se obtendrá una especificación del sistema, que consistirá en</li>
                    <li><strong>Diseño:</strong> Durante esta fase, se traducen los requisitos resultado de la fase
                        de análisis en componentes de software (tablas de una base de datos, programas
                        con procedimientos o funciones, clases con atributos y métodos, interfaz de usuario,
                        etc.). Se trata de un refinamiento de la fase anterior. Por ejemplo, en esta fase,
                        una de las decisiones que habrá que tomar es decidir qué sistema gestor de base
                        de datos (SGBD) se va a emplear para gestionar la información que debe ser usada
                        o generada por la aplicación: Oracle, MySQL, SQL Server, etcétera.</li>
                    <li><strong>Programación:</strong> consiste en traducir los resultados de la fase de diseño en una forma
                        legible para la máquina, es decir, se escribe el código fuente de cada componente
                        del software empleando un determinado lenguaje de programación. El
                        resultado de esta etapa es el código ejecutable.</li>
                    <li><strong>Pruebas:</strong> con estas se comprueba si la aplicación funciona correctamente. Hay diferentes
                        tipos de pruebas. Así, se comienza probando cada componente de software
                        por separado (pruebas unitarias) y, posteriormente, se van integrando poco a poco los
                        componentes (pruebas de integración), hasta probar el programa completo (pruebas de validación), cuyo objetivo es comprobar que la aplicación satisface los requisitos
                        del cliente. Como resultado de estas pruebas, se descubrirán errores, en atención a
                        los cuales, será necesario modificar el código, o incluso rehacer las tareas previas de
                        diseño y/o análisis.</li>
                    <li><strong>Explotación:</strong> en esta etapa, se lleva a cabo la instalación y puesta en marcha del
                        software en el entorno de trabajo del cliente.</li>
                    <li><strong>Mantenimiento:</strong> el software sufrirá cambios después de que se entregue al cliente
                        por diversos motivos. La tarea de mantenimiento consiste en realizar cambios sobre
                        el software, para lo que se aplicará al programa existente, cada una de las actividades
                        precedentes del ciclo de vida en vez de a uno nuevo.</li>
                        <img class="imagen-centrada" src="../imagenes/imagendesarrolloaplicación.png" alt="Imagen desarrollo aplicacion">
                        
                </ol>

                <p>Es necesario llevar a cabo otra tarea, que debe comenzar tras la comunicación inicial con el cliente y que es una actividad
                    más de gestión que técnica. Se trata de la tarea de planificación, que consiste en elaborar
                    un plan del proyecto de software que indique las tareas técnicas que se han de realizar,
                    los riesgos probables, los recursos que se necesitan, los productos de trabajo que
                    se obtendrán y una programación de las actividades.
                    Es preciso realizar otras tareas adicionales, de menor carácter técnico y también relacionadas con la gestión,
                    y que Pressman (2010) llamó actividades sombrilla:</p>
                <ol>
                    <li><strong>Seguimiento y control del proyecto de software:</strong> se debe evaluar periódicamente el
                        proyecto comparándolo con el plan preestablecido con el fin de tomar acciones si
                        se produce algún desvío respecto al plan.</li>
                    <li><strong>Administración del riesgo:</strong> consiste en evaluar los riesgos (problemas) que pueden
                        afectar al resultado del proyecto o a la calidad del producto.</li>
                    <li><strong>Aseguramiento de la calidad del software:</strong> se definen y ejecutan las actividades necesarias
                        para garantizar la calidad del software.</li>
                    <li><strong>Revisiones técnicas:</strong> se evalúan los productos obtenidos con el fin de descubrir y eliminar
                        errores antes de que se propaguen a la siguiente actividad.</li>
                    <li><strong>Medición:</strong> consiste en definir y reunir las mediciones del proceso, proyecto y producto
                        para ayudar al equipo a entregar el software que satisfaga las necesidades del
                        cliente.</li>
                    <li><strong>Administración de la configuración del software:</strong> se administran los efectos del cambio
                        a lo largo del proceso de desarrollo de software.</li>
                    <li><strong>Administración de la reutilización:</strong> se establecen los criterios para poder usar productos
                        del trabajo en proyectos posteriores y los mecanismos para que esto se
                        pueda llevar a la práctica, es decir, para obtener componentes reutilizables.</li>
                    <li><strong>Preparación y producción del producto del trabajo:</strong> se agrupan las actividades necesarias
                        para crear productos del trabajo, como modelos, documentos, registros, formatos,
                        etcétera.</li>
                </ol>
                <br></br>

                <p>A continuacion hablaremos mas detalladamente sobre las actividades estructurales de la ingenieria del softaware.</p>

                <h3 class="titulo-centrado">Analisis</h3>
                <p>El objetivo de esta actividad estructural de análisis es lograr una comprensión clara del
                    problema que se necesita resolver o, dicho de otro modo, de los requisitos funcionales
                    que debe cumplir la aplicación que el cliente ha encargado.
                    Esta tarea no es sencilla por diversos motivos:</p>
                    <ul>
                        <li>El cliente puede no tener claro qué requisitos debe satisfacer la aplicación.</li>
                        <li>El cliente tiene claros los requisitos, pero no es capaz de expresarlos de manera
                            comprensible para el equipo de desarrollo.</li>
                        <li>Puede haber malentendidos entre el equipo de desarrollo y el cliente por la razón
                            indicada en el punto anterior, por desconocimiento del problema que hay que resolver
                            por parte del equipo de desarrollo, o por desconocimiento de lo que la tecnología
                            puede ofrecer por parte del cliente.</li>
                        
                    </ul>
                    <p>Además de los requisitos funcionales, que hacen referencia a lo que tiene que hacer la
                        aplicación, hay otro tipo de requisitos llamados no funcionales, como los siguientes:</p>
                    
                    <ul>
                        <li><strong>Fiabilidad:</strong> grado en que una aplicación funciona sin fallos.</li>
                        <li><strong>Escalabilidad:</strong> capacidad del sistema para manejar aumentos de carga sin disminuir
                            el rendimiento.</li>
                        <li><strong>Extensibilidad:</strong> capacidad del software para añadir nuevas funcionalidades y componentes.</li>
                        <li><strong>Seguridad:</strong> grado con que una aplicación protege la información contra el acceso indebido
                            a ella.</li>
                        <li><strong>Mantenibilidad:</strong> grado en que el software es comprendido, reparado o mejorado.</li>        
                    </ul>

                    <p>Antes de elaborar los modelos que son el resultado de la fase de análisis, es necesaria
                        una tarea de comunicación con el cliente, para la que se pueden emplear distintas técnicas,
                        como:</p>

                    <ol>
                        <li><strong>Entrevistas:</strong> es la técnica más tradicional. Es similar a una entrevista periodística en
                            la que el analista entrevista, uno a uno, a los futuros usuarios del software.</li>
                        <li><strong>Desarrollo conjunto de aplicaciones</strong> se crea un equipo de analistas y usuarios que se reúnen para trabajar
                            conjuntamente en la determinación de las necesidades de los usuarios.</li>
                        <li><strong>Desarrollo de un prototipo:</strong> consiste en construir un modelo o maqueta del sistema
                            que permite ver a los usuarios las características del sistema que desean obtener.
                            El prototipo se puede o bien usar solo para este fin y se desecha, o bien se puede
                            mejorar para convertirlo en el producto final.</li>
                    </ol>

                    <p>Como resultado de esta fase, se debe obtener un documento llamado especificación de
                        requisitos del software (ERS), que sirve de base para la siguiente etapa de diseño.
                        En esta etapa, se crearán tanto diagramas de clases como diagramas de casos de uso.</p>
                        <img class="imagen-centrada" src="../imagenes/imagenanalisis.png" alt="Imagen analisis">

                    <br></br>
                        <h3 class="titulo-centrado">DISEÑO</h3>
                        <p>En la etapa de diseño, se determina cómo
                        se ha de solucionar dicho problema. Para ello, se partirá de los diagramas obtenidos en
                        la etapa de análisis, refinando algunos de ellos y creando otros que indiquen los pasos
                        que hay que dar para responder a los requisitos establecidos.</p>
                        
                        <h3 class="titulo-centrado">PROGRAMACIÓN</h3>
                        <p>Se parte del diseño detallado y, en esta fase, se escribe el código fuente correspondiente
                            siguiendo las normas del lenguaje de programación de alto nivel seleccionado.
                            Es habitual que se establezcan determinadas normas a la hora de escribir el código fuente
                            con el fin de que los programas tengan un aspecto homogéneo y sean fáciles de entender y, por tanto, de modificar, sobre todo si se tiene en cuenta la relevancia de las
                            posteriores tareas de mantenimiento. Normalmente, se establecen normas en relación
                            con los siguientes elementos:</p>
                            <ul>
                                <li><strong>Comentarios:</strong> se suelen escribir al comienzo de determinadas partes del código
                                    para describir su razón de ser (al comienzo de una clase, al indicar cada atributo de
                                    una clase, al comienzo de cada método, etc.) y para aclarar determinadas porciones
                                    de código por su alto nivel de complejidad.</li>
                                <li><strong>Declaraciones</strong> de variables y de parámetros de métodos.</li>
                                <li><strong>Nombres</strong> de clases, atributos, métodos, variables, constantes, etc.</li>
                                <li><strong>Líneas en blanco</strong> entre clases, métodos, etc.</li>
                                <li><strong>Sangrados</strong> para facilitar la legibilidad del código.</li>
                            </ul>

                        <h3 class="titulo-centrado">PRUEBAS</h3>
                        <p>El objetivo de esta actividad es detectar errores en el software antes de que este sea entregado
                            al cliente. La estrategia que se aplica en dichas pruebas consiste en realizarlas
                            desde los elementos más pequeños hasta los más grandes, es decir, se comienza probando
                            pequeños componentes de software hasta llegar al programa completo.
                            El objetivo de las pruebas es doble: verificar y validar el software.</p>
                            <ul>
                                <li>Por medio de la verificación, se determina si el software se ha construido correctamente,
                                    es decir, si las tareas que realiza las lleva a cabo de manera adecuada.</li>
                                <li>La validación consiste en comprobar si el software es realmente el que el usuario
                                    desea, o sea, si el sistema hace lo que quiere el usuario.</li>
                            </ul>
                            <p>Existen dos tipos de técnicas de pruebas:</p>
                            <ol><strong>pruebas de caja blanca o pruebas estructurales:</strong> se examinan los detalles de cada
                                módulo, para lo que se debe disponer del código fuente. Así, se prueban los diferentes
                                caminos a través de este código, así como los bucles, las variables, etcétera.</ol>
                                <br>
                            <ol><strong>pruebas de caja negra o pruebas funcionales:</strong> el software se considera como
                                una caja negra que recibe una serie de entradas y proporciona una serie de salidas.
                                El objetivo es validar los requisitos funcionales.</ol>
                                <img class="imagen-centrada" src="../imagenes/imagenpruebascajas.png" alt="Imagen prueba cajas">

                                <h3 class="titulo-centrado">EXPLOTACIÓN</h3>
                                <p>Una vez que se ha probado el software, se han corregido los errores detectados y se ha
                                    documentado todo el proceso, se lleva a cabo la instalación y la puesta a punto y en funcionamiento
                                    de la aplicación en las instalaciones del cliente. Durante esta fase, es necesaria
                                    la presencia del cliente. Por lo tanto, las tareas de esta fase son:</p>
                                    <ul>
                                        <li>Se instalan los programas en el equipo o los equipos del cliente.</li>
                                        <li>Se llevan a cabo las comprobaciones conocidas como pruebas beta, que se realizan
                                            en las instalaciones del cliente.</li>
                                        <li>Se realiza la configuración del sistema y se comprueba que la aplicación funciona
                                            de manera adecuada.</li>
                                        <li>Una vez completados los pasos anteriores, la aplicación ya pasa a la fase de producción
                                            normal, esto es, a su uso por parte del usuario final.</li>
                                    </ul>

                                <h3 class="titulo-centrado">MANTENIMIENTO</h3>
                                <p>Hay diferentes tipos de mantenimiento en función del motivo que lo origina:</p>
                                <ul>
                                    <li><strong>Mantenimiento correctivo:</strong> este se debe a que el cliente detecta errores en el software
                                        a pesar de las pruebas que se realizaron, y consiste en corregir estos errores.</li>
                                    <li><strong>Mantenimiento adaptativo:</strong> en muchos casos el software deba adaptarse a cambios
                                        del entorno externo porque, por ejemplo, se tiene un nuevo sistema operativo. Este
                                        tipo de mantenimiento se realiza frecuentemente por los rápidos avances en el ámbito
                                        de la informática.</li>
                                    <li><strong>Mantenimiento perfectivo:</strong> es muy común que, con el paso del tiempo, el cliente solicite
                                        ampliaciones funcionales, es decir, desee que la aplicación incorpore nuevos
                                        requisitos funcionales. Asi mismo, es posible que se deseen mejoras en requisitos
                                        no funcionales, por ejemplo, que el programa se ejecute más rápidamente o que se
                                        incremente la seguridad del sistema.</li>
                                </ul>
                                <br></br>

                                <h2>Roles que intervienen en el proceso de desarrollo de software</h2>
                                <br></br>
                                <ul><strong>-Jefe de proyecto:</strong> lleva a cabo la tarea de planificación del proyecto</ul>
                                <ul><strong>-Expertos del dominio:</strong> son personas que trabajan en la empresa u organismo para
                                    el que hay que desarrollar la aplicación y que conocen el dominio del problema,</ul>
                                <ul><strong>-Analista:</strong> su cometido es la tarea de análisis,</ul>
                                <ul><strong>-Arquitecto:</strong> a partir del trabajo realizado por el analista, debe definir las líneas
                                    maestras del diseño, estableciendo la arquitectura del sistema,</ul>
                                <ul><strong>-Diseñador</strong> parte de un subconjunto de los requisitos definidos por el analista y de
                                    la arquitectura del sistema para diseñar las partes del sistema que implementan
                                    esos requisitos hasta un nivel de detalle suficiente para acometer la tarea de programación.</ul>
                                <ul><strong>-Programador:</strong>se encarga de la tarea de programación.</ul>
                                <ul><strong>-Probador:</strong>se encarga de la tarea de pruebas</ul>
                                <ul><strong>-Encargado de la implantación:</strong> es el encargado de que se realice el empaquetado
                                    de los programas y su instalación en el entorno de trabajo del cliente.</ul>

                
            </div>
        </div>
        <br></br>
        <!--CUARTO APARTADO -->
        <div class="contenedor2">
            
           <div class="contenedor-ajustartexto">

            <h1 class="titulo-centrado">Modelos de ciclo de vida del software</h1>
            <p>Piattini et al. (2007) proporcionan la siguiente definición para el concepto de ciclo de
                vida: «el ciclo de vida del software es la descripción de las distintas formas de desarrollo
                de un proyecto o aplicación informática, es decir, la orientación que debe seguirse para
                obtener, a partir de los requerimientos del cliente, sistemas que puedan ser utilizados
                por dicho cliente».
                Un ciclo de vida determina el orden en el que se deben llevar a cabo las tareas en el proceso
                de desarrollo de software y los criterios que se deben cumplir para realizar el paso de una tarea a la siguiente. 
                El ciclo de vida que surgió en primer lugar es el llamado ciclo de vida clásico o modelo
                en cascada. Posteriormente, se desarrollaron otros modelos: de proceso incremental, de proceso evolutivo y de desarrollo ágil. En los siguientes apartados, se describe cada uno
                de ellos.</p>

        <ul>
            <li><strong> MODELO EN CASCADA:</strong> El modelo en cascada, también llamado ciclo de vida clásico, es el modelo más primitivo
                de ciclo de vida, pero ha resultado fundamental para el progreso posterior porque en él
                se identifican ya prácticamente todas las clases de actividades distintas que intervienen
                en el desarrollo y explotación de software. 
                En este modelo, se propone un enfoque sistemático y secuencial para el desarrollo de software, comenzando con el análisis y continuando a través del diseño, la programación
                y las pruebas hasta llegar al software terminado, sobre el que se pueden aplicar también operaciones de mantenimiento. 
                Se plantea un flujo secuencial de las actividades y para pasar de una fase a la siguiente
                es necesario cumplir ciertos objetivos. Para detectar los errores lo antes posible y evitar que se propaguen a fases posteriores, se establece un proceso de revisión al completar
                cada fase, antes de pasar a la siguiente. Esta revisión se realiza fundamentalmente sobre la documentación producida en esa fase y se hace de una manera formal. Si, a pesar
                de todo, durante la realización de una fase, se detectan errores en el resultado de
                fases anteriores, será necesario rehacer parte del trabajo volviendo a un punto anterior del ciclo de vida,</li>
                <p>Por ejemplo, si en la etapa de mantenimiento, se detecta que se cometió algún error en el diseño, será necesario
                    corregir dicho error de diseño y realizar cambios en las etapas posteriores de programación
                    y pruebas.</p>
                    <img class="imagen-centrada" src="../imagenes/imagenmodelocascada.png" alt="Imagen modelo cascada">


            <li><strong>MODELO DE PROCESO INCREMENTAL:</strong> Uno de los inconvenientes más importantes del modelo en cascada es que el cliente no
                dispone de una versión funcional del sistema hasta muy tarde. En muchos casos puede resultar
                más conveniente proporcionar cierta funcionalidad parcial del software al cliente y
                aumentarla en entregas posteriores. De esta manera, se concibe el desarrollo de software
                como un proceso en el que se van produciendo diversos incrementos o entregables. Para la
                elaboración de cada incremento, se siguen las actividades del modelo en cascada que se
                indicaron anteriormente.</li>
                <img class="imagen-centrada" src="../imagenes/imagenmodeloproceso.png" alt="Imagen modelo incremental">
                <p>VENTAJAS DE ESTE MODELO:
                    <ul>
                        <li>Reduce los riesgos de retrasos, de cambios de requisitos y problemas de aceptación.</li>
                        <li>Los entregables intermedios facilitan la retroalimentación por parte de los clientes,
                            lo cual resulta ventajoso para evitar problemas mayores en los siguientes entregables.</li>
                        <li>Permiten al usuario validar el sistema a medida que se construye.</li>
                    </ul>
                </p>

            <li><strong>MODELO DE PROCESO EVOLUTIVO</strong> Los modelos de proceso evolutivo tienen su razón de ser en el hecho de que «el software,
                como todos los sistemas complejos, evoluciona en el tiempo. Es frecuente que los requerimientos
                del negocio y del producto cambien conforme avanza el desarrollo, lo que hace
                que no sea realista trazar una trayectoria rectilínea hacia el producto final [...] Se comprende
                bien el conjunto de requerimientos o el producto básico, pero los detalles del producto
                o extensiones del sistema aún están por definirse» </li>
                <p>Estos modelos son iterativos y se caracterizan por el desarrollo de versiones cada vez más
                    completas del software. Se presentan a continuación dos modelos de proceso evolutivo:</p>
                    <ul>
                        <li><strong>Construcción de prototipos</strong> Un prototipo se puede definir como un sistema auxiliar que permite probar experimentalmente
                            ciertas soluciones parciales a las necesidades del usuario o a los requisitos del
                            sistema. Puede tratarse de un modelo que describa la interacción hombre-máquina, de
                            manera que facilite al usuario la comprensión de cómo se producirá la interacción, o un
                            programa que implemente algunos subconjuntos de la funcionalidad de la aplicación. Es
                            conveniente seguir este modelo de ciclo de vida cuando el cliente es capaz de definir un
                            conjunto de objetivos generales para el software, pero no puede identificar los requerimientos
                            en detalle, o cuando las personas desarrolladoras tienen dudas considerables
                            sobre determinados aspectos importantes del desarrollo, como la eficiencia de un algoritmo,
                            en qué medida la aplicación se podrá usar en un determinado sistema operativo o
                            de qué forma se ha de llevar a cabo la interacción hombre-máquina. Se puede considerar
                            este modelo de ciclo de vida de manera aislada, pero es más común emplearlo como
                            una técnica que puede implementarse en el contexto de cualquiera de los modelos de ciclo
                            de vida descritos en este tema.</li>
                            <p>En este modelo, se construye el software a partir de versiones cada vez más completas,
                                de manera que se realizan una serie de tareas varias veces. En la primera iteración, se
                                llevan a cabo las tareas (planificación, modelado, construcción, despliegue, evaluación y comunicación) para construir una primera versión del prototipo. La realización
                                de todas estas actividades constituye una iteración, luego se vuelven a realizar estas mismas tareas en la segunda iteración para obtener una segunda versión del prototipo
                                más completa, y así sucesivamente.</p>
                                <img class="imagen-centrada" src="../imagenes/imagenmodelado.png" alt="Imagen modelo">

                        <li><strong>Modelo en espiral</strong> Este modelo evolutivo fue diseñado para cubrir las mejores características tanto del modelo
                            en cascada como del modelo de construcción de prototipos, añadiendo un nuevo
                            elemento, que es el análisis de riesgo, dentro de la actividad estructural de planificación.
                            Como modelo de desarrollo evolutivo que es, el software se desarrolla en una serie de
                            entregas que se pueden representar como iteraciones o vueltas alrededor de una espiral.
                            Durante las primeras iteraciones lo que se entrega puede ser un modelo o prototipo.</li>
                            <img class="imagen-centrada" src="../imagenes/imagenmodeloespiral.png" alt="Imagen modelo espiral">
                            <p>La principal ventaja de este modelo es que la consideración de los riesgos o problemas
                                que pueden afectar al desarrollo del software en diferentes momentos permite que tanto
                                quienes encargaron el software como los que lo desarrollan sean conscientes de los
                                problemas que pueden presentarse y sean capaces de reaccionar en caso de que estos
                                ocurran. Además, si hay cierta inseguridad en cuanto a sus requisitos, se puede aplicar
                                el enfoque de construcción de prototipos para eliminar ese riesgo.
                                El principal inconveniente de este modelo es, como indica Pressman (2010), que
                                «requiere mucha experiencia en la evaluación del riesgo y se basa en ella para llegar al
                                éxito. No hay duda de que habrá problemas si algún riesgo importante no se descubre y
                                administra».</p>

                    </ul>

            <div class="contenedor-imagen">
                <img src="../imagenes/modelociclo2.jpg" alt="Imagen de Modelo">
            </div>
            <div class="Contenedor2-texto">
                <h1 class="titulo">Modelos de ciclo de vida del software</h1>

                <ul>
                    <li><strong> Modelo en Cascada</strong> Todo se hace en orden, paso a paso: primero planeas, luego
                        diseñas,
                        después programas, pruebas y finalmente entregas.</li>
                    <li><strong>Modelo en Espiral</strong> Trabajas por ciclos. En cada ciclo haces un poco de
                        planificación,
                        pruebas y mejoras. Repites hasta tener el software listo.</li>
                    <li><strong>Modelo Incremental</strong> Creas partes pequeñas del software (módulos) y las vas
                        entregando
                        una por una. Cada vez el software es más grande y funcional.
                    </li>
                    <li><strong>Modelo Iterativo</strong> Comienzas con una versión básica del software y la mejoras en
                        varias
                        vueltas (iteraciones), según la retroalimentación.</li>
                    <li><strong>Modelo de Prototipos</strong> Haces una versión rápida y básica (prototipo) del software
                        para
                        que los usuarios lo prueben y te digan qué cambiar.</li>
                    <li><strong>Modelo Ágil</strong> Trabajas en pequeños ciclos (llamados sprints, de 2-4 semanas) y
                        entregas
                        algo funcional al final de cada uno. Todo el equipo colabora y adapta el plan según las
                        necesidades.
                    </li>
                    <li><strong>Modelo DevOps</strong> Desarrollo y operación trabajan juntos para que el software esté
                        siempre
                        listo, con herramientas que automatizan todo (como actualizaciones).</li>
                    <li><strong>Modelo V</strong> Cada paso de desarrollo (como diseñar) tiene su paso de prueba
                        correspondiente
                        (como verificar que el diseño funcione).</li>
                </ul>

            </div>
        </div>


        <br></br>
        <br></br>

        <!--QUINTO APARTADO -->
        <div class="contenedor1">
            

            <div class="contenedor-ajustartexto">
                <h1 class="titulo-centrado">Metodologías de desarrollo de softaware actuales</h1>
                <p>metodología es un conjunto de filosofías, fases, procedimientos, reglas, técnicas, herramientas, documentación
                    y aspectos de formación para los desarrolladores de sistemas de información». Una
                    metodología puede seguir uno o varios modelos de ciclo de vida, esto es, el ciclo de vida
                    indica qué es lo que hay obtener a lo largo del desarrollo del proyecto, pero no cómo, que
                    es lo que indicará la metodología.</p>
                <p>Las metodologías de desarrollo de software han ido evolucionando a lo largo del tiempo.
                    Así, se identifican tres periodos de tiempo:</p>
                    <ol>
                        <li><strong>Desarrollo convencional:</strong> durante los primeros años del desarrollo de software las
                            prácticas de desarrollo eran totalmente artesanales y no se seguía ninguna metodología,
                            lo que acarreaba multitud de problemas y desembocó en lo que se llamó la
                            crisis del software.</li>
                        <li><strong>Metodologías estructuradas:</strong> la primera respuesta a esta crisis fue la regulación de
                            la tarea de programación con la difusión de la programación estructurada, a la que
                            siguió el surgimiento de métodos para el diseño y análisis estructurado, dando lugar
                            a las metodologías estructuradas, que abarcan la totalidad del ciclo de vida del
                            software.</li>
                        <li><strong>Metodologías orientadas a objetos:</strong> en la década de los 80 del siglo pasado surgieron,
                            en primer lugar, los lenguajes orientados a objetos y más tarde, métodos para
                            el diseño y análisis orientados a objetos.</li>
                    </ol>

                <p>Recientemente, se han desarrollado metodologías de desarrollo novedosas conocidas
                    como modelos de desarrollo ágil, que intentan simplificar las metodologías existentes,
                    buscando un equilibrio entre seguir un proceso de desarrollo que sea excesivo o «muy
                    burocrático» y su inexistencia.</p>

                
             <!--SEXTO APARTADO -->
             <div class="contenedor2">

                <div class="contenedor-ajustartexto">
                    <h1 class="titulo-centrado">El proceso unificado de Rational (RUP)</h1>
                    <p>El proceso RUP se puede describir en función de dos dimensiones:</p>
                    <ul><strong>-Dimensión temporal:</strong> se expresa en términos de ciclos, fases, iteraciones e hitos.</ul>
                    <ul><strong>-Dimensión estática:</strong> se expresa en términos de actividades (activities), productos
                        intermedios (artifacts), perfiles de trabajo o roles (workers) y flujos de trabajo
                        (workflow).</ul>
                    
                        <p>El ciclo de vida se divide en ciclos entendiendo estos
                            como vueltas alrededor de una espiral, y estas, a su vez, como los periodos de tiempo
                            en los que se trabaja sobre una versión completa del sistema. Cada ciclo se compone
                            de cuatro fases que se realizan secuencialmente:</p>
                            <ul>
                                <li><strong>Fase de comienzo (inception):</strong> el objetivo de esta fase es estudiar la viabilidad del
                                    sistema. Para ello, se establece el objetivo del sistema y se delimita su alcance,
                                    definiendo, además, las estimaciones de recursos y un plan de tiempos general en
                                    el que se establecen los hitos principales, las previsiones financieras, los riesgos
                                    del proyecto y los criterios para su éxito.</li>
                                <li><strong>Fase de elaboración (elaboration):</strong> los objetivos de esta fase son analizar el dominio
                                    del problema, establecer una base de la arquitectura software, desarrollar el plan del
                                    proyecto y eliminar los riesgos más importantes.</li>
                                <li><strong>Fase de construcción (construction):</strong> durante esta fase se desarrolla el sistema de
                                    forma iterativa e incremental hasta que esté preparado para su puesta en funcionamiento.
                                    Para cada iteración, se seleccionan algunos casos de uso (requisitos),
                                    se refina su análisis y diseño y se procede a su implementación y pruebas.</li>
                                <li><strong>Fase de transición (transition)</strong> el propósito de esta fase es poner en funcionamiento
                                    el sistema y ponerlo a disposición de los usuarios.</li>
                            </ul>
                                    <p>Cada una de las fases de RUP puede descomponerse en iteraciones. Una iteración es un
                                        periodo de tiempo en el que se realiza un conjunto completo de actividades de desarrollo.
                                        El sistema, por lo tanto, se va desarrollando incrementalmente de iteración en iteración.
                                        Una nueva iteración produce una nueva versión que proporciona al software mayor
                                        funcionalidad y es más refinada.</p>
                                    <p>El proceso RUP describe los perfiles o papeles de trabajo
                                        (quién) que realizan productos intermedios (qué) como resultado de realizar un conjunto
                                        de actividades (cómo) por medio de un flujo de trabajo predefinido (cuándo). De esta
                                        forma, el RUP establece cuatro elementos de modelado principales:</p>
                                        <ul>
                                            <li><strong>Perfiles o papeles de trabajo (workers):</strong> mediante el papel o rol de trabajo se define
                                                el comportamiento y la responsabilidad de una persona o un grupo de personas
                                                que trabajan como una unidad y en equipo.</li>
                                            <li><strong>Actividad (activity):</strong> es una unidad de trabajo que lleva a cabo un individuo con un
                                                rol determinado. Por ejemplo, para el papel del jefe o jefa de proyecto, una actividad
                                                podría ser planificar una iteración.</li>
                                            <li><strong>Producto intermedio (artifact):</strong> son elementos de información producidos, modificados
                                                o usados para el desarrollo del software.</li>
                                            <li><strong>Flujos de trabajo (workflows):</strong>son secuencias de actividades para producir productos
                                                intermedios. RUP define nueve flujos de trabajo agrupados en dos clases principales:
                                            <ul>-FLUJOS DE INGENIERIA </ul>
                                                <ol>
                                                    <li><strong>Modelado del negocio (business modelling):</strong> el objetivo es entender el conjunto
                                                        de procesos de negocio que aparecen dentro de la empresa como un paso
                                                        previo a la recogida de requisitos del sistema que se debe desarrollar.</li>
                                                    <li><strong>Requisitos (requirements):</strong> el propósito es establecer los requisitos funcionales
                                                        (qué debe hacer el sistema) mediante casos de uso y los requisitos
                                                        no funcionales (rendimiento, restricciones, facilidad de mantenimiento, fiabilidad,
                                                        etc.).</li>
                                                    <li><strong>Análisis y diseño (analysis 8: design):</strong> en esta fase se analizan los requisitos
                                                        capturados anteriormente con el objeto de tener una comprensión y descripción
                                                        más precisa de los mismos, se refinan y se estructuran.</li>
                                                    <li><strong>Implementación (implementation):</strong> consiste en programar o implementar el
                                                        sistema en términos de componentes, es decir, ficheros de código fuente,
                                                        ejecutables, etcétera.</li>
                                                    <li><strong>Pruebas (test):</strong>incluye crear casos de prueba (especificando qué probar y
                                                        cómo realizar la prueba), realizar las pruebas y evaluar sus resultados.</li>
                                                    <li><strong>Implantación (deployment):</strong>el objetivo es asegurarse de que el producto está
                                                        preparado para ser suministrado al cliente, ajustar el producto de software a
                                                        las necesidades del usuario y organizar su entrega y la recepción por parte
                                                        del usuario.</li>
                                                        <ul>-FLUJOS DE APOYO</ul>
                                                    <li><strong>Gestión de la configuración:</strong> control de cambios sobre los productos intermedios.</li>
                                                    <li><strong>Gestión de proyecto:</strong> planificación del proyecto, gestión de los riesgos y monitorización
                                                        del progreso del proyecto.</li>
                                                    <li><strong>Entorno:</strong> cubre la infraestructura necesaria para desarrollar un sistema.</li>
                                                    <img class="imagen-centrada" src="../imagenes/imagenmodelorup.png" alt="Imagen modelo rup">
                                                   
                                                </ol></li>
                                
                                        </ul>
                                    </ul>
                                        <br></br>
                                        <br></br>
                                        
                                        <h1 class="titulo-centrado">Modelos de desarrollo ágil</h1>
                                        <p>En el desarrollo ágil, se pone el énfasis en la entrega al cliente, cada poco tiempo, de
                                            software que funcione, más que en el rigor en la ingeniería del software y en los productos
                                            intermedios. Uno de los objetivos es la entrega rápida de software incremental y para
                                            ello se prefiere formar equipos pequeños y bien motivados.</p>
                                        <p>Una de las principales ventajas del desarrollo ágil es su mayor facilidad para incorporar
                                            los cambios a lo largo del desarrollo y el menor coste que estos cambios conllevan.
                                            Como sabemos, cuanto más tarde en el proceso de desarrollo se detecta la necesidad
                                            de realizar un cambio, más costoso es incorporarlo.</p>

                                            <img class="imagen-centrada" src="../imagenes/imagencomparación.png" alt="Imagen ciclo vida vs modelo desarrollo">
                                        <p>La Alianza Ágil ha establecido doce principios de agilidad</p>
                                        <ol>
                                            <li>La máxima prioridad es satisfacer al cliente a través de la entrega rápida y continua
                                                de software valioso.</li>
                                            <li>Los requisitos cambiantes son bienvenidos, aun en etapas avanzadas del desarrollo,
                                                pues, cuando hay cambios, los procesos ágiles son beneficiosos para la ventaja
                                                competitiva del cliente.</li>
                                            <li>Se realizan entregas frecuentes y lo más pronto que se pueda de software que funcione,
                                                preferiblemente entre dos semanas y un par de meses.</li>
                                            <li>Las personas responsables del negocio y las encargadas del desarrollo del software
                                                trabajan conjuntamente, a diario y durante todo el proyecto.</li>
                                            <li>Los proyectos son desarrollados por individuos motivados. Debe proporcionarse a
                                                estos el entorno y el apoyo adecuados, y confiar en que harán el trabajo.</li>
                                            <li>El método más eficiente y eficaz para comunicar información al equipo de desarrollo
                                                y entre sus miembros es la conversación cara a cara.</li>
                                            <li>La principal medida para progresar es un software que funcione.</li>
                                            <li>Los procesos ágiles impulsan el desarrollo sostenible. Los promotores, las personas
                                                que desarrollan el software y las usuarias de este deben ser capaces de mantener
                                                un ritmo constante de forma indefinida.</li>
                                            <li>La atención continua a la excelencia técnica y al buen diseño mejoran la agilidad.</li>
                                            <li>Es esencial la simplicidad: el arte de maximizar la cantidad de trabajo no realizado.</li>
                                            <li>Las mejores arquitecturas, requisitos y diseños surgen de los equipos con organización
                                                propia.</li>
                                            <li>El equipo reflexiona con regularidad sobre cómo ser más eficaz, para después perfeccionar
                                                y ajustar su comportamiento en consecuencia.</li>
                                                <img class="imagen-centrada" src="../imagenes/imagencicloincremental.png" alt="Imagen ciclo incremental">  

                                        </ol>
                                        <br></br>
                                        <p>Seguidamente, se presentan dos modelos concretos de desarrollo ágil:</p>
                                        <h2>Propagación extrema</h2>
                                        <p>Los cinco valores originales de la programación extrema son la simplicidad, la comunicación,
                                            la retroalimentación, la valentía y el respeto. A continuación, se describen brevemente
                                            cada uno de ellos:</p>
                                            <ul>
                                                <li><strong>Simplicidad:</strong> se debe simplificar el diseño para agilizar el desarrollo y facilitar el
                                                    mantenimiento. Solo se diseña de forma inmediata lo necesario. Si se tuviera que
                                                    mejorar el diseño, siempre se puede rediseñar o realizar una refactorización con
                                                    posterioridad.</li>
                                                <li><strong>Comunicación:</strong> debe establecerse una comunicación cercana pero informal con el
                                                    cliente; debe existir una retroalimentación continua y se deben evitar los documentos
                                                    voluminosos como medio de comunicación.</li>
                                                <li><strong>Retroalimentación:</strong> al realizar incrementos de software en cortos intervalos de tiempo,
                                                    los cuales son mostrados al cliente una vez terminados, se obtiene una retroalimentación
                                                    continua y frecuente, lo que evita tener que rehacer partes importantes del trabajo.
                                                    Las pruebas son una fuente esencial de la retroalimentación.</li>
                                                <li><strong>Valentía:</strong> cumplir con las prácticas de la programación extrema requiere valentía.
                                                    Por ejemplo, no se debe diseñar pensando en requisitos futuros, aunque llevar esto
                                                    a la práctica es difícil, pues la mayoría de los equipos de desarrollo de software
                                                    suelen recibir presión para que tengan en cuenta también los requerimientos futuros.</li>
                                                <li><strong>Respeto:</strong> el cumplimiento de los cuatro principios anteriores conlleva respeto entre
                                                    los miembros del equipo de desarrollo y entre estos y las demás personas que participan
                                                    en el proyecto.</li>
                                                    <br></br>
                                                    <p>Por otro lado, en la estructuración del proceso de desarrollo de software, se llevan a
                                                        cabo las siguientes cuatro actividades estructurales: planificación, diseño, codificación y
                                                        pruebas:</p>
                                                <li><strong>Planificación:</strong></li>
                                                <li><strong>Diseño:</strong></li>
                                                <li><strong>Codificación:</strong> Codificación: antes de la codificación, se diseñan pruebas unitarias para cada una
                                                    de las historias. Una vez creado el código, se aplica la prueba unitaria creada para
                                                    proporcionar retroalimentación a las personas que lo han desarrollado.</li>
                                                <li><strong>Pruebas:</strong> además de las pruebas unitarias que se hacen una vez creado el código,
                                                    también se realizan continuamente pruebas de integración y validación,</li>
                                            </ul>
                                            <br>
                                            <br>
                                            <h2>Scrum</h2>
                                            <p>Este modelo de desarrollo ágil tiene como objetivo la entrega de valor (productos) al
                                                cliente en cortos periodos de tiempo y se basa en tres pilares: transparencia, inspección
                                                y adaptación:</p>
                                                <img class="imagen-centrada" src="../imagenes/imagenscum.png" alt="Imagen scrum">

                                      
                </div>

             </div>

             

            </div>

        </div>

        <br>
        <br>
        <br>
        <br>
        <br>
        <!--Parte final, redes sociales, contacto, términos legales, etc-->

    </div>

    <div class="contenedorfinal">
        <br>
        <footer class="contenedorfinal">
            <div class="footer-container">
                <div>
                    <h2>Development Project</h2>
                    <p>We are an Information company about computer science, more specifically about programming.
                    </p>
                    <div class="socials">
                        &emsp;<a href="#">Instagram</a>
                        <a href="#">Twitter</a>
                        <a href="#">Gmail</a>
                    </div>
                </div>
                <div>
                    <h3>Resources</h3>
                    <a href="#">Cssbuttons.io</a><br>
                    <a href="#">Javascript.io</a><br>
                    <a href="#">Html.io</a><br>
                    <a href="#">C/C++.io</a>

                </div>
                <div>
                    <h3>Information</h3>
                    <a href="#">Blog</a><br>
                    <a href="#">Our offices</a><br>
                    <a href="#">WorkStations</a>
                </div>
                <div>
                    <h3>Legal</h3>
                    <a href="#">Terms</a><br>
                    <a href="#">Privacy</a><br>
                    <a href="#">Cookies</a>
                </div>
            </div>
            <p class="footer-bottom">&copy; 2024 Development Project.Inc</p>
        </footer>

    </div>
    <script type="text/javascript" src="../java/java.js"></script>
</body>

</html>